/*
SQLyog Ultimate v10.00 Beta1
MySQL - 5.5.27 : Database - sg_blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_blog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `sg_blog`;

/*Table structure for table `sg_article` */

DROP TABLE IF EXISTS `sg_article`;

CREATE TABLE `sg_article` (
  `id` bigint(200) NOT NULL AUTO_INCREMENT,
  `title` varchar(256) DEFAULT NULL COMMENT '标题',
  `content` longtext COMMENT '文章内容',
  `summary` varchar(1024) DEFAULT NULL COMMENT '文章摘要',
  `category_id` bigint(20) DEFAULT NULL COMMENT '所属分类id',
  `thumbnail` varchar(256) DEFAULT NULL COMMENT '缩略图',
  `is_top` char(1) DEFAULT '1' COMMENT '是否置顶（1是，0否）为了配合前端的失误',
  `status` char(1) DEFAULT '1' COMMENT '状态（0已发布，1草稿）',
  `view_count` bigint(200) DEFAULT '0' COMMENT '访问量',
  `is_comment` char(1) DEFAULT '1' COMMENT '是否允许评论 1是，0否',
  `create_by` bigint(20) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(20) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int(1) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8mb4 COMMENT='文章表';

/*Data for the table `sg_article` */

insert  into `sg_article`(`id`,`title`,`content`,`summary`,`category_id`,`thumbnail`,`is_top`,`status`,`view_count`,`is_comment`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'SpringSecurity从入门到精通','## 课程介绍\n![image20211219121555979.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/e7131718e9e64faeaf3fe16404186eb4.png)\n\n## 0. 简介1\n\n​	**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\n\n​	一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\n\n​	 一般Web应用的需要进行**认证**和**授权**。\n\n​		**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\n\n​		**授权：经过认证后判断当前用户是否有权限进行某个操作**\n\n​	而认证和授权也是SpringSecurity作为安全框架的核心功能。\n\n\n\n## 1. 快速入门\n\n### 1.1 准备工作\n\n​	我们先要搭建一个简单的SpringBoot工程\n\n① 设置父工程 添加依赖\n\n~~~~\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n~~~~\n\n② 创建启动类\n\n~~~~\n@SpringBootApplication\npublic class SecurityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SecurityApplication.class,args);\n    }\n}\n\n~~~~\n\n③ 创建Controller\n\n~~~~java\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n\n~~~~\n\n\n\n### 1.2 引入SpringSecurity\n\n​	在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\n\n~~~~xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n~~~~\n\n​	引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\n\n​	必须登陆之后才能对接口进行访问。\n\n\n\n## 2. 认证\n\n### 2.1 登陆校验流程\n![image20211215094003288.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/414a87eeed344828b5b00ffa80178958.png)','SpringSecurity框架教程-Spring Security+JWT实现项目级前端分离认证授权',1,'https://image.itbaima.net/images/173/image-202308291586746.png','0','0',132,'0',NULL,'2022-01-23 23:20:11',7,'2023-08-21 12:44:45',0),(9,'本blog跟随三更开发过程中遇到的bug与解决方案合集','\n\n# 1:b站评论区留下的bug\n\n## 1.p38 前端代码问题\n\n用网页登录提示用户名有问题的，看一下前端代码sg-blog-vue\\src\\api\\user.js\n\n里面的userLogin函数，传的username改成userName，数据库以及entity里面都是userName\n\n## 2.P55 注意大小写问题\n\n记录一个踩过的坑：\n背景：“个人中心”页面的数据填充是从缓存里拿的，在登录成功后，会将用户信息存到缓存里，\n用的key是“userInfo”。\n坑：我在定义BlogUserLoginVo的UserInfoVo属性是，属性名写成了\nuserInfoVo。也就导致了“个人中心”页面的user信息没有自动填充。\n\n## 3.p83 mp的updateById和updateBathByIds方法问题\n\n遇到的一个小坑，就是定时任务执行批量更新时出现空指针异常问题（如果有相同情况的朋友，\n希望会有点帮助），解决代码如下：\n\n```java\n   @Scheduled(cron = \"* 0/10 * * * ?\")\n    public void updateViewCount() {\n        //获取redis中浏览量数据\n        Map<String, Integer> viewCountMap = \nredisCache.getCacheMap(SystemConstants.ARTICLE_VIEWCOUNT);\nList<Article> articles = viewCountMap.entrySet()\n            .stream()\n            .map(entry ->\n                    new Article(Long.valueOf(entry.getKey()), entry.getValue().longValue()))\n            .collect(Collectors.toList());\n\n    for (Article article : articles) {\n        LambdaUpdateWrapper<Article> updateWrapper = new LambdaUpdateWrapper<>();\n        updateWrapper.eq(Article :: getId, article.getId());\n        updateWrapper.set(Article :: getViewCount, article.getViewCount());\n        articleService.update(updateWrapper);\n    }\n```\n\n## 5.P124 前端代码问题，关于是否置顶前端写反了\n\n1. 关于是否置顶前端好像写反了,可以打开后端文件搜是否置顶把label标签的1和0互换,\n   2.图片不显示的应该是admin模块的application文件里没加oss的key\n   3.围观数量可能不变是因为自己写的文章viewcount没有缓存在redis里,\n   只有程序重新启动项目更新redis才会有,可以在save后自己保存在redis里\n\n## 6.P151 前端代码问题，用户?没有及时显示的解决办法\n\n~~~vue\n<el-form-item label=\"角色\">\n              <el-select v-model=\"form.roleIds\" multiple placeholder=\"请选择\" \n@change=\"$forceUpdate()\">\n\n# \n~~~\n\n\n\n # 2:我遇到的bug:\n\n## 1.报错：执行（Long）（redisCache.getCacheObject(key)）时报错：String 不能转换为 Long\n\n原因：\n\n```java\n（Long）（redisCache.getCacheObject(key)）\n```\n\n从Redis中获取value时直接强转为Long\nGPT回答：\n**对于 Redis 来说，存储的 value 其实是经过序列化后的字节流。**在 Java 中，\n可以使用各种序列化框架（如 Java 自带的序列化、Jackson、Fastjson、Protobuf 等）\n将对象转换为字节流，然后再将字节流存储到 Redis 中。\n\n**当从 Redis 中获取存储的 value 时，Redis 将字节流反序列化为相应的对象**。\n但由于 Redis 是一个键值存储系统，它本身并不了解被存储的数据的具体类型。\n因此 **Redis 在反序列化时，由于存储的 value 其实是经过序列化后的字节流，所以不知道对象的原始类型，只能将其转换为字符串对象存储在内存中**。\n这就是为什么获取的时候会变成字符串类型的原因。\n\n当你从 Redis 中获取到存储的字符串类型时，需要根据具体的业务逻辑，\n自行将其转换回原始类型。例如，在你的示例中，你可以使用 Long.parseLong() \n方法将字符串类型的值转换为 Long 类型。\n\n需要注意的是，在存储和获取时要保证一致的序列化方案，\n即存储和获取时使用相同的序列化框架和参数，以免出现序列化和反序列化不匹配的问题。\n\n## 2.报错：使用@RequestBody Long id,注解接收前端json里面的数字参数7时：\n\n```json\n{\n    \"id\": 7,\n    \"name\": \"c++\",\n    \"remark\": \"c艹死路一条\"\n}\n```\n\n报错：\n\n```json\n\"code\": 500,\n\"msg\": \"can not cast to int, value : {\\\"id\\\":7,\\\"name\\\":\\\"c++\\\",\\\"remark\\\":\\\"c艹死路一条\\\"}\"\n```\n\n原因(csdn)：long类型没有对应的key value值，sping不能正确解析，long就自己一个字段，\nspring它不是把参数名和你接收的名字对应，是**和你接收的对象的字段对应的** \n解决方案：使用@RequestBody注解接收前端的参数时，**要封装一个dto类，**\n**使用类中的属性进行接收**\n\n注意：post,put请求携带的参数通常都是存储在请求体中，接收时封装一个Dto使用@RequestBody Dto进行接收\n\n## 3.调用articleTagService.insert方法时报错：\n\n起因:mp的save方法不能指定插入的id，id默认为自增，id为4时想插入id为10是不可以的（好像有方法但是比较复杂）,不如自定义sql进行实现:\n\n~~~java\narticleTagService.insert(articleTag.getArticleId(),articleTag.getTagId());\n~~~\n\n~~~java\nvoid insert(Long articleId,Long tagId);\n~~~\n\n### 异常信息：\n\norg.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter \'articleId\' not found. Available parameters are [arg1, arg0, param1, param2]\n\n### 原因：\n\nsql方法中有多个参数时**，没有添加@Param注解**指定Map的key，@Param(\"articleId\") Long articleId指定一个Map，其中key为\"articleId\"，value为Long articleId的值，传输给Mybatis中执行的sql语句，使用#{articleId}获取（相当于map.get(\"articleId\")）\n\nArticleTagMapper中的insert方法应为：\n\n```java\nvoid insert(@Param(\"articleId\") Long articleId, @Param(\"tagId\") Long tagId);\n```\n\n## 4.与mp相关的bug\n\n### (1)update（obj）方法\n\n​	设置obj的del_flag属性后sql语句中并没有del_flag，即不会更新，想要删除只能使用removeById方法或自定义\n\n### (2)removeById(obj)方法，obj没有del_flag属性时，执行的sql为delete语句\n\n### (3)updateById()与updateBatchById()方法\n\n​		定时任务UpdateViewCountJob类中使用mp的update方法就报错：java.lang.NullPointerException。原因不明\n\n：\n\n~~~java\narticleService.updateBatchById(articles);\n~~~\n\n现在：使用自定义的ArticleMapper.xml中的sql：\n\n`\n\n```xml\nupdate sg_article set view_count = #{viewCount} where id = #{articleId} and del_flag = 0;`\n```\n\n\n\n~~~java\narticles.forEach(article -> articleService.updateViewCountToMysql(article.getId(),article.getViewCount()));\n\n~~~\n\n\n\n\n\n\n\n## 5 前端permission.js文件错误，导致登录不了后台管理系统\n\n前端工程\\sg-vue-admin\\src\\store\\modules\\permission.js这个路径下面的permission.js文件的一行代码\n\n```javascript\nchildrenRouterList.psuh(children)\n```\n\n写错了。应该把psuh改为push的，这个bug导致140p左右登录不了后台管理系统[脱单doge]\n\n\n\n## 6 BeanCopyUtils相关的bug\n\n   \n\n~~~java\nBeanCopyUtil.beanListCopy(records, UserVo.class)\n~~~\n\n只有records中的对象的属性的**类型**与**名字** 与userVo**都相同时**才会进行拷贝！\n\n## 7 数据库中user表与评论表中的user对不上,测试后把user删除时没有触发器来删除用户留下的评论导致数据对不上，最终抛出空指针异常\n\n## 8 新增文章后，注意要把新增文章的id与ViewCount(即默认0)存储到Redis中的浏览量map中   \n\n\n\n不然在前台的获取热门文章列表时随便查询了浏览量map给文章更新最新的浏览量时，由于新增的文章的数据并没有存储在map中，导致null指针异常\n\n解决方式：在写文章之后添加新的文章数据到map中，替换Redis中原来的map\n\nredisCache.setCacheMap(SystemConstants.VIEWCOUNT_MAP_KEY,map);\n\n```java\n        //保存后获取所有的文章列表\n        List<Article> articles = list();\n        //存储在map集合中\n        Map<String,Integer> map = articles.stream()\n                .collect(Collectors.toMap(article1 -> article1.getId().toString()\n                        //value值转换为Integer类型而不是Long，后面才能进行递增\n                        , article1 -> article1.getViewCount().intValue()));\n        //更新Redis中的文章与访问量的数据\n        redisCache.setCacheMap(SystemConstants.VIEWCOUNT_MAP_KEY,map);\n\n```\n\n\n\n启动器中也是同样的方法，内部是redisTemplate.opsForHash().putAll(key,map)方法;\n\n```java\n    /**\n     * 程序启动时将数据库中每篇文章的访问量的数据存储到map中最后存储到Redis中\n     *\n     * @param args\n     * @throws Exception\n     */\n    @Override\n    public void run(String... args) throws Exception {\n        //获取所有的文章列表\n        List<Article> articles = articleMapper.selectList(null);\n        //存储在map集合中\n        Map<String, Integer> map = articles.stream()\n                .collect(Collectors.toMap(article -> article.getId().toString()\n                        //value值转换为Integer类型而不是Long，后面才能进行递增\n                        , article -> article.getViewCount().intValue()));\n        //存储到Redis中\n\n        redisCache.setCacheMap(SystemConstants.VIEWCOUNT_MAP_KEY, map);\n\n        //redisTemplate.opsForValue().set(SystemConstants.VIEWCOUNT_MAP_KEY,map);\n\n    }\n```\n\n![](http://ryhyqcp22.hn-bkt.clouddn.com/2023/08/12/bc91244f38c34e9d8072bccf857d3caa.png)\n\n关注java喵，关注java谢谢喵！\n\n\n\n\n\n','包括：1.b站评论区留下的bug\n          2.我遇到的bug',1,'https://image.itbaima.net/images/173/image-20230829151492114.png','1','0',27,'0',7,'2023-08-21 12:08:10',1,'2023-08-25 07:40:20',0),(10,'git的使用','## 1.提交文件到远程仓库\n\n### (1)空文件夹时：\n\ngit init\ngit remote add 远程仓库名字 https链接\ngit pull 远程仓库名 远程分支\n修改文件\ngit add 文件\ngit commit -m \' 注释 \'\n\n### (2)已有要提交的文件时：\n\n先保存在本地仓库生成hash码后再pull拉取进行覆盖，为push做准备  **存疑**\ngit add...\ngit commit -m...\ngit pull 远仓名 远分支\ngit reset --hard...\ngit push 远仓名 本分支：远分支\n\n## 2.常用命令：\n\n克隆指定分支:git clone -b 远分支 远链接\ngit commit -a -m \'注释\'\ngit log --all --graph --oneline 用一行、图像显示所有分支的提交情况\ngit reflog显示历史所有的(包括其它人)提交情况\ngit checkout,branch,remote add,\ngit remote -v 查看远仓名\ngit push 远程仓库名 本地分支：远程分支\n\n(1.)merge合并：并不合并分支，merge只把两个分支不冲突的提交进行合并，两个分支仍然可以提交新的文件\n(2).(master)git merge test 把test分支中不冲突的提交合并到master中(test分支不变，只把test分支中与master分支不冲突的提交给拷贝到master分支，然后再连线。)\n(3.)发生冲突时：直接在本分支解决冲突(修改文件，随便修改？)后提交，test分支与master分支都会指向刚刚修改的提交。\n\n\n变基rebase\ngit rebase master ->把当前分支变基到master分支中，相同的文件合并在master分支中，不同的文件以master的最新提交作为起点，把两个分支合并为一个分支，两个分支仍然可以提交新的文件\n\ncherry-pick优选：\ngit cherry-pick commit哈希码 把对应的提交拷贝过来作为新的提交提交到本分支中','git常用命令',6,'https://image.itbaima.net/images/173/image-20230821215345935.png','1','0',10,'0',7,'2023-08-21 13:18:26',7,'2023-08-21 13:22:09',0),(11,'aop应用型笔记','## Aop的使用\n\n#### 准备工作\n\n##### 添加依赖\n\n需要添加SpringIOC相关依赖和AOP相关依赖。\n\n~~~~xml\n        <!--SpringIOC相关依赖-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n        <!--AOP相关依赖-->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n~~~~\n\n## 1:切点表达式execution\n\n​		可以使用切点表达式来表示要对哪些方法进行增强。\n\n\n\n### 1.1写法：**execution([修饰符] 返回值类型 包名.类名.方法名(参数))**\n\n- 访问修饰符可以省略，大部分情况下省略\n- 返回值类型、包名、类名、方法名可以使用星号*  代表任意\n- 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类\n- 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表\n\n\n\n例如：\n\n```java\nexecution(* com.sangeng.service.*.*(..))   表示com.sangeng.service包下任意类，方法名任意，参数列表任意，返回值类型任意\n   \nexecution(* com.sangeng.service..*.*(..))   表示com.sangeng.service包及其子包下任意类，方法名任意，参数列表任意，返回值类型任意\n    \nexecution(* com.sangeng.service.*.*())     表示com.sangeng.service包下任意类，方法名任意，要求方法不能有参数，返回值类型任意\n    \nexecution(* com.sangeng.service.*.delete*(..))     表示com.sangeng.service包下任意类，要求方法不能有参数，返回值类型任意,方法名要求已delete开头\n```\n\n### 1.2使用：\n\n~~~java\n	//对哪些方法增强\n    @Pointcut(\"execution(* com.sangeng.service..*.*(..))\")\n    public void pt(){}\n~~~\n\n\n\n## 2.切点函数@annotation+注解方式 (环绕通知)\n\n\n\n### 2.1自定义一个注解\n\n~~~java\n/**\n * 自定义注解用来标识实现aop增强\n */\n@Target(ElementType.METHOD)//只能作用于方法上面\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SystemLog {\n    //注意：定义了一个属性而不是方法\n    String BusinessName();\n}\n\n~~~\n\n\n\n### 2.2创建一个日志打印切面类\n\n~~~java\n@Component\n@Aspect//切面注解\n@Slf4j//日志打印注解 酸辣粉4j\npublic class LogAspect {\n    //指定切点(增强对象)为被打上这个注解的方法\n    @Pointcut(\"@annotation(com.kana.annotation.SystemLog)\")\n    public void pt(){\n\n    }\n    //使用环绕方法设置通知内容并且设置作用范围\n    @Around(\"pt()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        //处理前进行打印\n        handleBefore(joinPoint);\n        Object res = null;\n        try {\n            //执行原方法\n            res = joinPoint.proceed();\n            //处理后进行打印\n            handleAfter(res);\n        }finally{\n            // 结束后换行\n            log.info(\"=======End=======\" + System.lineSeparator());\n        }\n        return res;\n    }\n\n    private void handleAfter(Object object) {\n        // 打印出参\n        log.info(\"Response       : {}\", JSON.toJSONString(object));\n    }\n\n    private void handleBefore(ProceedingJoinPoint joinPoint){\n        Object[] args = joinPoint.getArgs();\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        String classPath = signature.getDeclaringTypeName();\n        String methodName = signature.getName();\n        //获取http请求封装而成的对象\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n        //获取被增强方法的注解对象以及注解内部的信息\n        SystemLog systemLog  = getAnnotation(signature);\n        String businessName = systemLog.BusinessName();\n        log.info(\"=======Start=======\");\n        // 打印请求 URL\n        log.info(\"URL            : {}\",request.getRequestURL());\n        // 打印描述信息\n        log.info(\"BusinessName   : {}\",businessName);\n        // 打印 Http method\n        log.info(\"HTTP Method    : {}\",request.getMethod() );\n        // 打印调用 controller 的全路径以及执行方法\n        log.info(\"Class Method   : {}.{}\",classPath,methodName);\n        // 打印请求的 IP\n        log.info(\"IP             : {}\",request.getRemoteHost());\n        // 打印请求入参  把对象进行json的序列化之后进行打印\n        log.info(\"Request Args   : {}\", JSON.toJSONString(args));\n    }\n\n    private SystemLog getAnnotation(MethodSignature signature){\n        return signature.getMethod().getAnnotation(SystemLog.class);\n    }\n}\n\n~~~\n\n### 2.3 设置作用于哪一个方法\n\n~~~java\n	@SystemLog(BusinessName = \"更新用户信息\")//打上注解启动aop\n    @PutMapping(\"/userInfo\")\n    //@RequestBody 告诉mvc请求头中有json格式的数据并赋值给user对象\n    public ResponseResult putUserInfo(@RequestBody User user){\n        return userService.putUserInfo(user);\n    }\n~~~\n\n\n\n## ','aop的使用',7,'https://image.itbaima.net/images/173/image-20230829158836522.png','1','0',16,'0',1,'2023-08-22 12:42:07',1,'2023-08-22 12:42:07',0),(12,'mybatis-plus应用型笔记','# mp的使用\n\n## 1:mp的配置\n\n### 1.1在application.yml中的相关配置\n\n~~~xml\nmybatis-plus:\n  configuration:\n    # 配置日志实现类\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n  global-config:\n    db-config:\n		#逻辑删除相关的设置\n      logic-delete-field: delFlag\n      logic-delete-value: 1\n      logic-not-delete-value: 0\n		#设置id增长类型为自动递增\n      id-type: auto\n#\n~~~\n\n### 1.2导入mp的依赖\n\n~~~xml\n        <!--mybatisPlus依赖-->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n            <version>3.4.3</version>\n        </dependency>\n\n~~~\n\n### 1.3mp开启分页查询的支持\n\n~~~java\n@Configuration\npublic class MbatisPlusConfig {\n\n    /**\n     * 3.4.0之后版本\n     * MP支持分页配置\n     * @return\n     */\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();\n        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n        return mybatisPlusInterceptor;\n    }\n}\n~~~\n\n\n\n## 2:配置MP字段update与insert时自动填充fill\n\n### 2.1 自定义一个类实现MetaObjectHandler接口重写对应的方法即可\n\n\n\n~~~java\n/***\n * 配置MP字段自动填充,自定义一个类实现MetaObjectHandler接口重写对应的方法即可\n */\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    /***\n     * 配置执行插入语句时自动更新一些公共的字段\n       当执行插入语句时就会调用此方法\n     * @param metaObject\n     */\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        Long userId = null;\n        try {\n            userId = SecurityUtils.getUserId();\n        } catch (Exception e) {\n            //处理注册时执行insert用户语句时，还没有登录导致获取不到userId时发生的异常\n            e.printStackTrace();\n            userId = -1L;//表示是自己创建\n        }\n        this.setFieldValByName(\"createTime\", new Date(), metaObject);\n        this.setFieldValByName(\"createBy\",userId , metaObject);\n        this.setFieldValByName(\"updateTime\", new Date(), metaObject);\n        this.setFieldValByName(\"updateBy\", userId, metaObject);\n    }\n\n    /***\n     * 配置执行更新语句时自动更新一些公共的字段\n     * @param metaObject\n     */\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        this.setFieldValByName(\"updateTime\", new Date(), metaObject);\n        this.setFieldValByName(\"updateBy\", SecurityUtils.getUserId(), metaObject);\n    }\n}\n~~~\n\n### 2.2在对应的实体类上打上相应的注解\n\n~~~java\n    @TableField(fill = FieldFill.INSERT)\n    private Long createBy;\n\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Long updateBy;\n\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n~~~\n\n## 3:使用xml映射文件和对应的mapper接口实现使用自定义的sql\n\n例如：MenuMapper与MenuMapper.xml\n\n**注意：MenuMapper.xml映射文件的位置在application.yml中默认是resources/mapper/MenuMapper.xml，如果需要修改，在application.yml中重新进行指定即可**\n\n\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<!--指定类路径    mapper接口名与Mybatis的映射文件名一定要一模一样。-->\n<mapper namespace=\"com.kana.mapper.MenuMapper\">\n    <!--指定执行sql的类型、方法名与返回类型-->\n    <select id=\"selectPermsByUserId\" resultType=\"java.lang.String\">\n        SELECT DISTINCT perms\n        FROM sys_user_role ur LEFT JOIN sys_role_menu rm\n        ON ur.`role_id` = rm.`role_id`\n        LEFT JOIN sys_menu m\n        ON m.`id` = rm.`menu_id`\n        WHERE ur.`user_id` = #{userId} AND\n        m.`status` = 0 AND\n        m.`menu_type` IN (\'C\',\'F\') AND\n        m.`del_flag` = 0\n    </select>\n\n    <select id=\"selectMenuByUserId\" resultType=\"com.kana.domain.entity.Menu\">\n    SELECT m.*\n    FROM sys_user_role ur LEFT JOIN sys_role r\n    ON ur.`role_id` = r.`id`\n    LEFT JOIN sys_role_menu rm\n    ON rm.`role_id` = r.`id`\n    LEFT JOIN sys_menu m\n    ON m.`id` = rm.`menu_id`\n    WHERE m.`del_flag` = 0 AND\n    m.`status` = 0 AND\n    m.`menu_type` IN (\'C\',\'M\') AND\n    ur.`user_id` = #{userId}\n    ORDER BY\n    m.parent_id,m.order_num\n    </select>\n</mapper>\n\n~~~\n\n## 4:其他使用可见sanGengBlogBugs中的mp相关的bug\n\n\n\n## 5实体类相关注解的使用\n\n~~~java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Accessors(chain = true)//开启链式调用\n@TableName(\"sg_article\")//对应数据库中名字为sg_article的表\npublic class Article{\n    @TableId//主键id,只能有一个，但是数据库表可能有两个主键\n    private Long id;\n    //标题\n    private String title;\n    //文章内容\n    private String content;\n    //文章摘要\n    private String summary;\n    //所属分类id\n    private Long categoryId;\n    //缩略图\n    private String thumbnail;\n    //是否置顶（0否，1是）\n    private String isTop;\n    //状态（0已发布，1草稿）\n    private String status;\n    //访问量\n    private Long viewCount;\n    //是否允许评论 1是，0否\n    private String isComment;\n	//使用mp自动填充\n    @TableField(fill = FieldFill.INSERT)\n    private Long createBy;\n\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Long updateBy;\n\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n\n    //删除标志（0代表未删除，1代表已删除）\n    private Integer delFlag;\n    //注解表示String categoryName不在数据库表中\n    @TableField(exist = false)\n    private String categoryName;\n\n    public Article(Long id, Long viewCount) {\n        this.id = id;\n        this.viewCount = viewCount;\n    }\n}\n\n\n~~~\n\n','mp的使用，从配置文件到每个注解的使用',7,'https://image.itbaima.net/images/173/image-2023082915837677.png','1','0',5,'0',1,'2023-08-22 12:46:54',1,'2023-08-22 12:46:54',0),(13,'springSecurity应用型笔记','\n\n# springSecurity实战登录验证jWT方案\n\n## 1登录验证 (从数据库中查询用户信息进行登录验证的流程)\n\n### 1.1:登录验证，登录成功则生成token并把用户信息存入Redis，最后返回token与用户信息给前端\n\n~~~java\n@Override\n    public ResponseResult login(User user) {\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        //authenticationManager.authenticate方法执行流程图中的方法，\n        // 自定义后查询数据库中用户信息并且与传入的信息进行加密对比，验证成功则写入Authentication对象返回，否则返回null\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n        if(Objects.isNull(authenticate)){\n            //验证失败\n            throw new RuntimeException(\"authenticationManager.authenticate验证出错：用户名或密码错误！\");\n        }\n        //验证成功根据用户id生成token\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String s_id = loginUser.getUser().getId().toString();\n        String jwt = JwtUtil.createJWT(s_id);\n        //根据用户id存储到Redis中\n        redisCache.setCacheObject(\"bloglogin:\"+s_id,loginUser);\n        //封装vo user拷贝出userInfoVo对象并且封装为blogUserLoginVo对象\n        UserInfoVo userInfoVo = BeanCopyUtil.beanCopy(loginUser.getUser(), UserInfoVo.class);\n        BlogUserLoginVo blogUserLoginVo = new BlogUserLoginVo(jwt, userInfoVo);\n        //封装为ResponseResult类返回\n        return ResponseResult.okResult(blogUserLoginVo);\n    }\n\n~~~\n\n### 1.2 让SpringSecurity从数据库中查询用户信息进行登录验证\n\n~~~java\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService {\n    @Autowired\n    private UserMapper userMapper;\n    @Autowired\n    private MenuService menuService;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        //使用mp的mapper查询用户对象\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(User::getUserName,s);\n        User user = userMapper.selectOne(queryWrapper);\n        if(user==null){\n            throw new RuntimeException(\"userMapper.selectOne()结果：用户不存在！\");\n        }\n        //如果是后台用户，才封装用户权限信息\n        if(user.getType().equals(SystemConstants.ADMIN)){\n            List<String> perms = menuService.selectPermsByUserId(user.getId());\n            return new LoginUser(user,perms);\n        }\n\n        return new LoginUser(user,null);\n    }\n}\n\n~~~\n\n其中LoginUser实现了UserDetails接口，具体为：\n\n~~~java\n/***\n * SpringSecurity框架会使用这个接口的方法获取用户名与密码、权限等等\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class LoginUser implements UserDetails {\n    private User user;\n    private List<String> permissions;\n\n    /***\n     * SpringSecurity框架会使用这个接口的方法获取权限信息\n     * 重写以给框架提供数据库中查询到的权限信息,也可以不写使用自定义的权限验证信息\n     * @return\n     */\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    /***\n     * SpringSecurity框架会使用这个接口的方法获取用户名与密码\n     * 重写以给框架提供数据库中查询到的用户信息\n     * @return\n     */\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUserName();\n    }\n\n    /***\n     * 全部改为true方便测试\n     * @return\n     */\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n~~~\n\n## 2添加过滤器\n\n\n\n### 2.1:继承OncePerRequestFilter类重写方法实现前端携带token发起请求时后端的验证流程\n\n\n\n 自定义过滤器后添加到SpringSecurity中\n\n```java\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n    @Autowired\n    private RedisCache redisCache;\n\n    /***\n     * 前端携带token发起请求时后端的验证流程\n     * @param httpServletRequest\n     * @param httpServletResponse\n     * @param filterChain\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doFilterInternal(HttpServletRequest httpServletRequest,\n                                    HttpServletResponse httpServletResponse,\n                                    FilterChain filterChain) throws ServletException, IOException {\n        //获取前端请求头中携带的token并解析出userId\n        String token = httpServletRequest.getHeader(\"token\");\n        //检测是否含有token\n        if(!StringUtils.hasText(token)){\n            //没有则说明此接口不需要登录,如果访问了需要登录的接口会被后面的过滤器拒绝，所以直接放行并return即可\n            filterChain.doFilter(httpServletRequest,httpServletResponse);\n            return;\n        }\n        String userId = \"\";\n        try {\n            Claims claims = JwtUtil.parseJWT(token);\n            userId = claims.getSubject();\n        } catch (Exception e) {\n            e.printStackTrace();\n            //出现异常进入这里说明 token失效 或 token被篡改\n            //返回响应给前端告诉他需要重新登录并return\n            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);\n            WebUtils.renderString(httpServletResponse, JSON.toJSONString(result));\n            return;\n        }\n        //从Redis中查询用户信息  后台使用\"login:\" + userId与前台进行区分\n        LoginUser loginUser = redisCache.getCacheObject(SystemConstants.BACKGROUND_REDIS_TOKEN_KEY_PREFIX + userId);\n        if(Objects.isNull(loginUser)){\n            //Redis查询不到信息，过期了\n            //返回响应给前端告诉他需要重新登录并return\n            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);\n            WebUtils.renderString(httpServletResponse, JSON.toJSONString(result));\n            return;\n        }\n        //把用户信息存储到SecurityContextHolder的authentication中\n        //这里需要使用3个参数的重载形式才有super.setAuthenticated(true); 设置已经完成了认证\n        UsernamePasswordAuthenticationToken authenticationToken = new\n                UsernamePasswordAuthenticationToken(loginUser,null,null);\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //放行\n        filterChain.doFilter(httpServletRequest,httpServletResponse);\n\n    }\n}\n\n```\n\n\n\n### 2.1在SecurityConfigure中把过滤器添加到springSecurity的过滤器链中\n\n~~~java\n	@Autowired\n    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n    \n		//添加自定义的过滤器到UsernamePasswordAuthenticationFilter之前\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n        \n~~~\n\n## 3退出登录\n\n\n\n### 3.1 退出登录接口的实现\n\n~~~java\n/***\n     *  退出登录功能的实现, 需要请求头中必须携带token才能正常访问 为什么呢？？\n     *  回答：因为没有携带token的话根本通过不了JwtAuthenticationTokenFilter过滤器，相当于没有登录，正常功能不能被访问，\n     *  包括退出登录接口\n     * @return\n     */\n    @Override\n    public ResponseResult logout() {\n        //获取userId并删除Redis中的用户信息\n        LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        redisCache.deleteObject(SystemConstants.RECEPTION_REDIS_TOKEN_KEY_PREFIX +userId);\n        return ResponseResult.okResult();\n    }\n~~~\n\n### 3.2 在SecurityConfigure中关闭默认的退出登录接口\n\n~~~java\n//关闭默认的退出登录接口，请求地址也是\"/logout\",防止与自定义的注销接口冲突\n        http.logout().disable();\n~~~\n\n## 4完整的SecurityConfigure配置类\n\n~~~java\n@Configuration\n//开启权限管理的支持\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfigure extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n\n    /***\n     * 注入AuthenticationManager到容器中\n     * @return\n     * @throws Exception\n     */\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /***\n     * 注入BCryptPasswordEncoder对象到容器中,SpringSecurity会自动使用BCryptPasswordEncoder进行加密\n     * @return\n     */\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext 关闭Session\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 只能匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部都需要认证才可访问\n                .anyRequest().authenticated();\n        //关闭默认的退出登录接口，请求地址也是\"/logout\",防止与自定义的注销接口冲突\n        http.logout().disable();\n        //允许跨域\n        http.cors();\n        //添加自定义的过滤器到UsernamePasswordAuthenticationFilter之前\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n        //添加自定义的认证、授权异常处理器\n        http\n                .exceptionHandling()\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n    }\n\n}\n\n~~~\n\n## 5自定义认证、授权失败时进行的处理(返回的信息)\n\n### 5.1自定义授权失败时触发的的异常处理器:\n\n~~~java\n/***\n * 自定义授权失败的异常处理器  AccessDeniedHandler访问被拒绝处理器\n */\n@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler{\n    /***\n     * 自定义没有权限操作时返回给前端的响应数据\n     * @param httpServletRequest\n     * @param httpServletResponse\n     * @param e\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void handle(HttpServletRequest httpServletRequest,\n                       HttpServletResponse httpServletResponse,\n                       AccessDeniedException e) throws IOException, ServletException {\n        e.printStackTrace();\n        ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NO_OPERATOR_AUTH);\n        WebUtils.renderString(httpServletResponse, JSON.toJSONString(result));\n    }\n}\n~~~\n\n### 5.2 自定义认证失败时触发的异常处理器\n\n~~~java\n@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\n    /***\n     * 登录失败时自定义返回给前端的信息\n     * @param httpServletRequest\n     * @param httpServletResponse\n     * @param e\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    public void commence(HttpServletRequest httpServletRequest,\n                         HttpServletResponse httpServletResponse,\n                         AuthenticationException e) throws IOException, ServletException {\n        //打印错误信息\n        e.printStackTrace();\n        ResponseResult result = null;\n        //用户不同的错误操作导致不同的异常类型，从而返回不同的错误信息\n        if(e instanceof InsufficientAuthenticationException){\n            //没有携带token进行访问就会触发InsufficientAuthenticationException，在这里设置返回数据\n            result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);\n        }else if(e instanceof InternalAuthenticationServiceException){\n            result = ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_ERROR,e.getMessage());\n        }else{\n            result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),\"认证错误！\");\n        }\n        //以JSON字符串的形式响应给前端\n        WebUtils.renderString(httpServletResponse, JSON.toJSONString(result));\n    }\n}\n\n~~~\n\n## 6全局异常处理器Controller,统一处理各种各样的异常\n\n### 6.1全局异常处理器\n\n~~~java\n//@RestBody与@ControllerAdvice的合体\n@Slf4j\n@RestControllerAdvice\n//酸辣粉4j，lombok的日志打印\npublic class GlobalExceptionHander{\n    /***\n     * 处理SystemException异常，把异常作为参数传入，处理完毕后返回ResponseResult对象给前端\n     * @param e\n     * @return\n     */\n    @ExceptionHandler(SystemException.class)\n    public ResponseResult systemExceptionHandler(SystemException e){\n        //打印异常信息 使用{}作为占位符传入异常e打印异常信息 虽然报红但是还可以使用\n        log.error(\"出现了异常!{}\",e);\n        return ResponseResult.errorResult(e.getCode(),e.getMsg());\n    }\n\n    /***\n     * 处理其他异常? Exception,设置返回给前端的数据\n     * @param e\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    public ResponseResult exceptionHandler(Exception e){\n        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),e.getMessage());\n    }\n}\n\n~~~\n\n### 6.2自定义一个异常，进行统一异常处理\n\n~~~java\npublic class SystemException extends RuntimeException{\n\n    private int code;\n\n    private String msg;\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public SystemException(AppHttpCodeEnum httpCodeEnum) {\n        //使用父类的构造器进行初始化\n        super(httpCodeEnum.getMsg());\n        this.code = httpCodeEnum.getCode();\n        this.msg = httpCodeEnum.getMsg();\n    }\n    \n}\n~~~\n\n### 6.3具体使用：\n\n~~~java\n@PostMapping(\"/login\")\n    public ResponseResult login(@RequestBody User user){\n        if(!StringUtils.hasText(user.getUserName())){\n            //会被GlobalExceptionHander的systemExceptionHandler(SystemException e)方法\n            //捕获并处理(类似try-catch配合Controller)\n            throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);\n        }\n        return loginService.login(user);\n    }\n\n~~~\n\n\n\n## 7springSecurity的权限控制\n\n### 7.1 SecurityConfig类中添加注解\n\n~~~java\n//开启权限管理的支持\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfigure extends WebSecurityConfigurerAdapter\n~~~\n\n### 7.2定义权限判断类\n\n~~~java\n/**\n * 权限判断类，判断当前用户是否有足够的权限进行访问\n */\n@Service(\"ps\")//命名为ps\npublic class PermissionService {\n    @Autowired\n    private RoleService roleService;\n    /**\n     * 判断当前用户是否拥有传入的权限\n     * @return\n     */\n    public boolean hasPermissions(String permission) {\n        //TODO 三更这里写错了 如果用户身份是管理员(RoleId==1)，直接返回true（数据库中没有记录管理员的权限数据）\n        Long RoleId = roleService.getRoleIdByUserId(SecurityUtils.getUserId());\n        if(RoleId.equals(SystemConstants.ADMIN_USER)){\n            return true;\n        }\n        //否则获取当前用户身份所具有的权限进行对比\n        List<String> permissions = SecurityUtils.getLoginUser().getPermissions();\n        return permissions.contains(permission);\n    }\n}\n\n~~~\n\n### 7.3给相应的方法设置需要的权限\n\n~~~java\n/**\n     * 删除标签\n     * @param id\n     * @return\n     */\n    //设置只有具有特定的权限的用户才能执行删除标签操作 使用ps类的hasPermissions方法进行判断,参数为content:tag:remove\n    @PreAuthorize(\"@ps.hasPermissions(\'content:tag:remove\')\")\n    @Override\n    public ResponseResult<Void> deleteTag(Long id) {\n        removeById(id);\n        return ResponseResult.okResult();\n    }\n\n~~~\n\n\n\n','springSecurity实战登录验证jWT方案',7,'https://image.itbaima.net/images/173/image-20230829152197429.png','1','0',5,'0',1,'2023-08-22 13:02:47',1,'2023-08-22 13:02:47',0),(14,'常用的应用型笔记','# 常用配置类、工具类、实体类、机制(上传下载文件)等\n\n\n\n## 8实用工具类\n\n### 8.1BeanCopyUtil\n\n~~~java\npublic class BeanCopyUtil {\n    private BeanCopyUtil() {\n    }\n\n    //方法上的泛型<V>,设置返回的类型为V类型，由传入Class参数的泛型决定V的类型\n    //类似于List<String>,Class<String>表示传入的是String的字节码对象\n    public static <V> V beanCopy(Object source, Class<V> clazz) {\n        V v = null;\n        try {\n            v = clazz.newInstance();\n            //使用org.springframework.beans.BeanUtils中的copyProperties方法\n            BeanUtils.copyProperties(source, v);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return v;\n    }\n\n    public static <V,O> List<V> beanListCopy(List<O> sourceLists, Class<V> clazz) {\n        //1.0写法:\n//        List<V> result = new ArrayList<>();\n//        for (O o : sourceLists) {\n//            result.add(beanCopy(o,clazz));\n//        }\n//        return result;\n        //2.0写法 stream操作\n        return sourceLists.stream()\n                .map(o->beanCopy(o,clazz))\n                .collect(Collectors.toList());\n\n    }\n}\n\n~~~\n\n### 8.2JWT工具类 根据id生成对应的token\n\n~~~java\npublic class JwtUtil {\n\n    //有效期为\n    public static final Long JWT_TTL = 24*60 * 60 *1000L;// 60 * 60 *1000  一个小时\n    //设置秘钥明文\n    public static final String JWT_KEY = \"sangeng\";\n\n    public static String getUUID(){\n        String token = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        return token;\n    }\n    \n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @return\n     */\n    public static String createJWT(String subject) {\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\n        return builder.compact();\n    }\n\n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @param ttlMillis token超时时间\n     * @return\n     */\n    public static String createJWT(String subject, Long ttlMillis) {\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\n        return builder.compact();\n    }\n\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\n        SecretKey secretKey = generalKey();\n        long nowMillis = System.currentTimeMillis();\n        Date now = new Date(nowMillis);\n        if(ttlMillis==null){\n            ttlMillis=JwtUtil.JWT_TTL;\n        }\n        long expMillis = nowMillis + ttlMillis;\n        Date expDate = new Date(expMillis);\n        return Jwts.builder()\n                .setId(uuid)              //唯一的ID\n                .setSubject(subject)   // 主题  可以是JSON数据\n                .setIssuer(\"sg\")     // 签发者\n                .setIssuedAt(now)      // 签发时间\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\n                .setExpiration(expDate);\n    }\n\n    /**\n     * 创建token\n     * @param id\n     * @param subject\n     * @param ttlMillis\n     * @return\n     */\n    public static String createJWT(String id, String subject, Long ttlMillis) {\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\n        return builder.compact();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String token = \"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\";\n        Claims claims = parseJWT(token);\n        System.out.println(claims);\n    }\n\n    /**\n     * 生成加密后的秘钥 secretKey\n     * @return\n     */\n    public static SecretKey generalKey() {\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\");\n        return key;\n    }\n    \n    /**\n     * 解析\n     *\n     * @param jwt\n     * @return\n     * @throws Exception\n     */\n    public static Claims parseJWT(String jwt) throws Exception {\n        SecretKey secretKey = generalKey();\n        return Jwts.parser()\n                .setSigningKey(secretKey)\n                .parseClaimsJws(jwt)\n                .getBody();\n    }\n\n\n}\n~~~\n\n### 8.3生成一个不重复的文件名的工具\n\n~~~java\npublic class PathUtils {\n    /**\n     * 生成一个不重复的文件名\n     * 传入文件名后根据日期和uuid拼接一个文件名并返回\n     * @param fileName\n     * @return\n     */\n    public static String generateFilePath(String fileName){\n        //根据日期生成路径   2022/1/15/\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd/\");\n        String datePath = sdf.format(new Date());\n        //uuid作为文件名，生成不重复的id\n        String uuid = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        //后缀和文件后缀一致\n        int index = fileName.lastIndexOf(\".\");\n        // test.jpg -> .jpg\n        String fileType = fileName.substring(index);\n        return new StringBuilder().append(datePath).append(uuid).append(fileType).toString();\n    }\n}\n~~~\n\n### 8.4Redis简化操作工具类\n\n~~~java\n@Component\npublic class RedisCache\n{\n    @Autowired\n    public RedisTemplate redisTemplate;\n\n    /**\n     * 对map中的value进行递增操作\n     * @param mapKey\n     * @param viewCountKey\n     * @param v\n     */\n    public void incrementCacheMapValue(String mapKey,String viewCountKey,int v){\n        redisTemplate.opsForHash().increment(mapKey,viewCountKey,v);\n    }\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     */\n    public <T> void setCacheObject(final String key, final T value)\n    {\n        redisTemplate.opsForValue().set(key, value);\n    }\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     * @param timeout 时间\n     * @param timeUnit 时间颗粒度\n     */\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\n    {\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\n    }\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout)\n    {\n        return expire(key, timeout, TimeUnit.SECONDS);\n    }\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\n    {\n        return redisTemplate.expire(key, timeout, unit);\n    }\n\n    /**\n     * 获得缓存的基本对象。\n     *\n     * @param key 缓存键值\n     * @return 缓存键值对应的数据\n     */\n    public <T> T getCacheObject(final String key)\n    {\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\n        return operation.get(key);\n    }\n\n    /**\n     * 删除单个对象\n     *\n     * @param key\n     */\n    public boolean deleteObject(final String key)\n    {\n        return redisTemplate.delete(key);\n    }\n\n    /**\n     * 删除集合对象\n     *\n     * @param collection 多个对象\n     * @return\n     */\n    public long deleteObject(final Collection collection)\n    {\n        return redisTemplate.delete(collection);\n    }\n\n    /**\n     * 缓存List数据\n     *\n     * @param key 缓存的键值\n     * @param dataList 待缓存的List数据\n     * @return 缓存的对象\n     */\n    public <T> long setCacheList(final String key, final List<T> dataList)\n    {\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\n        return count == null ? 0 : count;\n    }\n\n    /**\n     * 获得缓存的list对象\n     *\n     * @param key 缓存的键值\n     * @return 缓存键值对应的数据\n     */\n    public <T> List<T> getCacheList(final String key)\n    {\n        return redisTemplate.opsForList().range(key, 0, -1);\n    }\n\n    /**\n     * 缓存Set\n     *\n     * @param key 缓存键值\n     * @param dataSet 缓存的数据\n     * @return 缓存数据的对象\n     */\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\n    {\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\n        Iterator<T> it = dataSet.iterator();\n        while (it.hasNext())\n        {\n            setOperation.add(it.next());\n        }\n        return setOperation;\n    }\n\n    /**\n     * 获得缓存的set\n     *\n     * @param key\n     * @return\n     */\n    public <T> Set<T> getCacheSet(final String key)\n    {\n        return redisTemplate.opsForSet().members(key);\n    }\n\n    /**\n     * 缓存Map\n     *\n     * @param key\n     * @param dataMap\n     */\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\n    {\n        if (dataMap != null) {\n            redisTemplate.opsForHash().putAll(key, dataMap);\n        }\n    }\n\n    /**\n     * 获得缓存的Map\n     *\n     * @param key\n     * @return\n     */\n    public <T> Map<String, T> getCacheMap(final String key)\n    {\n        return redisTemplate.opsForHash().entries(key);\n    }\n\n    /**\n     * 往Hash中存入数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @param value 值\n     */\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\n    {\n        redisTemplate.opsForHash().put(key, hKey, value);\n    }\n\n    /**\n     * 获取Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @return Hash中的对象\n     */\n    public <T> T getCacheMapValue(final String key, final String hKey)\n    {\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\n        return opsForHash.get(key, hKey);\n    }\n\n    /**\n     * 删除Hash中的数据\n     * \n     * @param key\n     * @param hkey\n     */\n    public void delCacheMapValue(final String key, final String hkey)\n    {\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        hashOperations.delete(key, hkey);\n    }\n\n    /**\n     * 获取多个Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKeys Hash键集合\n     * @return Hash对象集合\n     */\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\n    {\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\n    }\n\n    /**\n     * 获得缓存的基本对象列表\n     *\n     * @param pattern 字符串前缀\n     * @return 对象列表\n     */\n    public Collection<String> keys(final String pattern)\n    {\n        return redisTemplate.keys(pattern);\n    }\n}\n~~~\n\n\n\n### 8.5 SecurityUtils 快速获取用户信息\n\n~~~java\npublic class SecurityUtils\n{\n\n    /**\n     * 获取用户\n     **/\n    public static LoginUser getLoginUser()\n    {\n        return (LoginUser) getAuthentication().getPrincipal();\n    }\n\n    /**\n     * 获取Authentication\n     */\n    public static Authentication getAuthentication() {\n        return SecurityContextHolder.getContext().getAuthentication();\n    }\n\n\n    public static Long getUserId() {\n        return getLoginUser().getUser().getId();\n    }\n}\n~~~\n\n### 8.6 返回数据给客户端的工具类\n\n~~~java\npublic class WebUtils\n{\n    /**\n     * 将字符串渲染到客户端\n     * \n     * @param response 渲染对象\n     * @param string 待渲染的字符串\n     * @return null\n     */\n    public static void renderString(HttpServletResponse response, String string) {\n        try\n        {\n            response.setStatus(200);\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"utf-8\");\n            response.getWriter().print(string);\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 设置用户下载、导出文件时接收到文件的响应格式\n     * @param filename\n     * @param response\n     * @throws UnsupportedEncodingException\n     */\n    public static void setDownLoadHeader(String filename, HttpServletResponse response) throws UnsupportedEncodingException {\n        response.setContentType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n        response.setCharacterEncoding(\"utf-8\");\n        String fname= URLEncoder.encode(filename,\"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n        response.setHeader(\"Content-disposition\",\"attachment; filename=\"+fname);\n    }\n}\n~~~\n\n\n\n\n\n## 9实体类、ResponseResult、AppHttpCodeEnum类\n\n### 9.1 ResponseResult类\n\n~~~java\n// 在将该对象转换为JSON字符串时，只有属性值不为null的属性才会被包含在生成的JSON字符串中，而属性值为null的属性则会被忽略。\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class ResponseResult<T> implements Serializable {\n    private Integer code;\n    private String msg;\n    private T data;\n\n    /***\n     * 无参构造器表示成功状态\n     */\n    public ResponseResult() {\n        this.code = AppHttpCodeEnum.SUCCESS.getCode();\n        this.msg = AppHttpCodeEnum.SUCCESS.getMsg();\n    }\n\n    public ResponseResult(Integer code, T data) {\n        this.code = code;\n        this.data = data;\n    }\n\n    public ResponseResult(Integer code, String msg, T data) {\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    }\n\n    public ResponseResult(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public static ResponseResult errorResult(int code, String msg) {\n        ResponseResult result = new ResponseResult();\n        return result.error(code, msg);\n    }\n    public static ResponseResult okResult() {\n        ResponseResult result = new ResponseResult();\n        return result;\n    }\n    public static ResponseResult okResult(int code, String msg) {\n        ResponseResult result = new ResponseResult();\n        return result.ok(code, null, msg);\n    }\n\n    public static ResponseResult okResult(Object data) {\n        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getMsg());\n        if(data!=null) {\n            result.setData(data);\n        }\n        return result;\n    }\n\n    public static ResponseResult errorResult(AppHttpCodeEnum enums){\n        return setAppHttpCodeEnum(enums,enums.getMsg());\n    }\n\n    public static ResponseResult errorResult(AppHttpCodeEnum enums, String msg){\n        return setAppHttpCodeEnum(enums,msg);\n    }\n\n    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums){\n        return okResult(enums.getCode(),enums.getMsg());\n    }\n\n    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String msg){\n        return okResult(enums.getCode(),msg);\n    }\n\n    public ResponseResult<?> error(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n        return this;\n    }\n\n    public ResponseResult<?> ok(Integer code, T data) {\n        this.code = code;\n        this.data = data;\n        return this;\n    }\n\n    public ResponseResult<?> ok(Integer code, T data, String msg) {\n        this.code = code;\n        this.data = data;\n        this.msg = msg;\n        return this;\n    }\n\n    public ResponseResult<?> ok(T data) {\n        this.data = data;\n        return this;\n    }\n\n    public Integer getCode() {\n        return code;\n    }\n\n    public void setCode(Integer code) {\n        this.code = code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    public void setData(T data) {\n        this.data = data;\n    }\n\n\n\n}\n~~~\n\n### 9.2AppHttpCodeEnum枚举类\n\n~~~java\npublic enum AppHttpCodeEnum {\n\n    // 成功\n    SUCCESS(200,\"操作成功\"),\n    // 登录\n    NEED_LOGIN(401,\"需要登录后操作\"),\n    NO_OPERATOR_AUTH(403,\"无权限操作\"),\n    SYSTEM_ERROR(500,\"出现错误\"),\n    USERNAME_EXIST(501,\"用户名已存在\"),\n     PHONENUMBER_EXIST(502,\"手机号已存在\"),\n    EMAIL_EXIST(503, \"邮箱已存在\"),\n    REQUIRE_USERNAME(504, \"必须填写用户名\"),\n    LOGIN_ERROR(505,\"用户名或密码错误\"),\n    COMMENT_IS_EMPTY(506,\"评论内容不能为空\"),\n    FILE_TYPE_ERROR(507,\"文件类型错误，请上传png格式\"),\n    USERNAME_ILLEGAL(508,\"用户名非法\"),\n    PASSWORD_ILLEGAL(509,\"密码非法\"),\n    EMAIL_ILLEGAL(510,\"邮箱非法\"),\n    NICKNAME_ILLEGAL(511,\"昵称非法\"),\n    NICKNAME_EXIST(512,\"昵称已存在\"),\n    CATEGORY_EXIST(513,\"此分类已存在\"),\n    HAVE_CHILDREN_MENU_NOT_APPLY_DELETE(513,\"存在子菜单不允许删除\");\n\n    int code;\n    String msg;\n\n    AppHttpCodeEnum(int code, String errorMessage){\n        this.code = code;\n        this.msg = errorMessage;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n}\n\n~~~\n\n\n\n## 10配置类\n\n### 10.1 配置Redis的序列化类\n\n~~~java\n/**\n * Redis使用FastJson序列化\n * \n * @author sg\n */\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\n{\n\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n\n    private Class<T> clazz;\n\n    static\n    {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    }\n\n    public FastJsonRedisSerializer(Class<T> clazz)\n    {\n        super();\n        this.clazz = clazz;\n    }\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException\n    {\n        if (t == null)\n        {\n            return new byte[0];\n        }\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    }\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException\n    {\n        if (bytes == null || bytes.length <= 0)\n        {\n            return null;\n        }\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    }\n\n\n    protected JavaType getJavaType(Class<?> clazz)\n    {\n        return TypeFactory.defaultInstance().constructType(clazz);\n    }\n}\n~~~\n\n\n\n### 10.2Redis配置类\n\n~~~java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    @SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\n    {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(serializer);\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n~~~\n\n\n\n### 10.3设置跨域、FastJson配置解决时间的显示\n\n~~~java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n      // 设置允许跨域的路径\n        registry.addMapping(\"/**\")\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(\"*\")\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\")\n                // 设置允许的header属性\n                .allowedHeaders(\"*\")\n                // 跨域允许时间\n                .maxAge(SystemConstants.CROS_ALLOW_TIME);\n    }\n\n    /***\n     * FastJson配置,解决时间显示格式不正常的问题\n     */\n    @Bean//使用@Bean注入fastJsonHttpMessageConvert\n    public HttpMessageConverter fastJsonHttpMessageConverters() {\n        //1.需要定义一个Convert转换消息的对象\n        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();\n        FastJsonConfig fastJsonConfig = new FastJsonConfig();\n        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);\n        fastJsonConfig.setDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        //把响应中所有Long类型转换为String类型，防止前端的long类型出现精度丢失，应该使用字符串来接收\n        SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);\n\n        fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);\n        fastConverter.setFastJsonConfig(fastJsonConfig);\n        HttpMessageConverter<?> converter = fastConverter;\n        return converter;\n    }\n\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.add(fastJsonHttpMessageConverters());\n    }\n\n}\n~~~\n\n### 10.4 Swagger的配置与使用\n\n#### 10.4.1 配置\n\n\n\n~~~java\n/**\n * swagger文档信息配置,设置上半部分的信息\n */\n@Configuration\npublic class SwaggerConfig {\n    @Bean\n    public Docket customDocket() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                //配置swagger的包扫描路径\n                .apis(RequestHandlerSelectors.basePackage(\"com.kana.Controller\"))\n                .build();\n    }\n\n    /**\n     * 配置swagger文档的介绍信息\n     * @return\n     */\n    private ApiInfo apiInfo() {\n        Contact contact = new Contact(\"kana\", \"http://www.kana.com\", \"13432241185@163.com\");\n        return new ApiInfoBuilder()\n                .title(\"前后端分离的博客系统\")\n                .description(\"后端基于SpringBoot2.5.0 + mybatis-plus + Redis + SpringSecurity,前端基于vue进行开发\")\n                .contact(contact)   // 联系方式\n                .version(\"1.1.0\")  // 版本\n                .build();\n    }\n}\n~~~\n\n#### 10.4.2 swagger注解的使用\n\n~~~java\n@RestController\n@RequestMapping(\"/comment\")\n//swagger的标签注释\n@Api(tags = \"评论标签\",description = \"评论相关接口\")\npublic class CommentController {\n    @Autowired\n    private CommentService commentService;\n\n\n    @GetMapping(\"/commentList\")\n    public ResponseResult commentList(Long articleId,Long pageNum,Long pageSize){\n        return commentService.commentList(SystemConstants.ARTICLE_COMMENT,articleId,pageNum,pageSize);\n    }\n\n    @PostMapping\n    public ResponseResult addComment(@RequestBody AddCommentDto addCommentDto){\n        //不使用与数据库进行映射的实体类，而是使用dto类，更加灵活\n        Comment comment = BeanCopyUtil.beanCopy(addCommentDto, Comment.class);\n        //@RequestBody:告诉springMVC从请求头中获取数据封装到comment对象中\n        return commentService.addComment(comment);\n    }\n\n    //swagger方法注释\n    @ApiOperation(value = \"友链评论接口\",notes = \"获取一页友链评论\")\n    @GetMapping(\"/linkCommentList\")\n    //swagger方法参数注释\n    @ApiImplicitParams({\n            @ApiImplicitParam(name = \"pageNum\", value = \"获取第几页的评论\"),\n            @ApiImplicitParam(name = \"pageSize\", value = \"一页获取多少条评论\")\n    }\n    )\n    \n    public ResponseResult linkCommentList(Long pageNum,Long pageSize){\n        return commentService.commentList(SystemConstants.LINK_COMMENT,null,pageNum,pageSize);\n    }\n\n}\n\n~~~\n\n\n\n## 12上传图片，下载导出文件(excel)\n\n### 12.1设置读取application.yml文章中的信息\n\n读取类中的配置：属性+set方法\n\n~~~java\n@Data\n//设置读取前缀,类中的属性会从application.yml中进行读取并使用set方法进行赋值\n@ConfigurationProperties(prefix = \"oss\")\npublic class OssUploadServiceImpl implements UploadService {\n    private String accessKey;\n    private String secretKey;\n    private String bucket;\n}\n~~~\n\napplication.yml中的配置：\n\n~~~yaml\n#oss为前缀，用于记录信息给其他类进行读取\noss:\n  accessKey: -11111-m-hi41222YljfYbCO3PgceqmpPA54\n  secretKey: _ns22222RMUaiDOz243AOe4IdNZZ6xxsOCsRAW\n  bucket: cxk-1\n\n~~~\n\n或使用@Value注解\n\n### 12.2 实现上传图片\n\n~~~java\n/**\n     * 接收前端上传的图片(MultipartFile对象)存储到七牛云的图床并把图片的链接(url)响应给前端\n     */\n    @Override\n    public ResponseResult uploadImg(MultipartFile img) {//使用MultipartFile类接收图片数据\n        //判断上传的文件类型\n        String originalFilename = img.getOriginalFilename();\n        assert originalFilename != null;\n        //只能上传png格式\n        if(!originalFilename.endsWith(\".png\")){\n            throw new SystemException(AppHttpCodeEnum.FILE_TYPE_ERROR);\n        }\n        //生成文件的存储路径（原始路径+新的文件名）\n        String filePath = PathUtils.generateFilePath(originalFilename);\n        //存储到七牛云的图床中并返回url\n        String url = uploadOSS(img,filePath);\n        return ResponseResult.okResult(url);\n    }\n\n~~~\n\n### 12.3实现下载文件例如：导出excel文件\n\n查看EasyExcel的文档，使用EasyExcel相关的api进行实现。\n\n~~~java\npublic void export(HttpServletResponse response){\n        try {\n            //设置下载文件时的响应头中的字段\n            WebUtils.setDownLoadHeader(\"文章分类数据.xlsx\",response);\n            //获取分类数据\n            List<Category> categories = categoryService.list();\n            List<ExcelCategoryVo> excelCategoryVos = BeanCopyUtil.beanListCopy(categories, ExcelCategoryVo.class);\n            //写入数据到Excel中，响应中返回文件数据而不是json数据\n            //设置写入的实体对象\n            EasyExcel.write(response.getOutputStream(), ExcelCategoryVo.class)\n                    //设置自动关闭流失效\n                    .autoCloseStream(Boolean.FALSE)\n                    //设置工作簿名称\n                    .sheet(\"分类导出\")\n                    //设置写入的具体数据\n                    .doWrite(excelCategoryVos);\n        } catch (Exception e) {\n            //出现异常则返回json数据\n            e.printStackTrace();\n            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR);\n            //设置写入响应的数据\n            WebUtils.renderString(response, JSON.toJSONString(result));\n        }\n\n    }\n\n~~~\n\n~~~java\n/**\n     * 设置用户下载、导出文件时接收到文件的响应格式\n     * @param filename\n     * @param response\n     * @throws UnsupportedEncodingException\n     */\n    public static void setDownLoadHeader(String filename, HttpServletResponse response) throws UnsupportedEncodingException {\n        response.setContentType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n        response.setCharacterEncoding(\"utf-8\");\n        String fname= URLEncoder.encode(filename,\"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n        response.setHeader(\"Content-disposition\",\"attachment; filename=\"+fname);\n    }\n~~~\n\n','常用配置类、工具类、实体类、机制(上传下载文件)等\n\n',7,'https://image.itbaima.net/images/173/image-20230829153686878.png','1','0',7,'0',1,'2023-08-22 13:41:06',1,'2023-08-22 13:41:06',0),(16,'test11','# test11','test11',1,'http://ryhyqcp22.hn-bkt.clouddn.com/2023/09/12/5376e7b403644c939bc6853319b9aee6.png','1','0',4,'0',7,'2023-09-12 07:17:37',1,'2023-10-13 22:11:59',0),(27,'百度','111','百度',1,'http://s2k69te8d.hn-bkt.clouddn.com/2023/10/15/3d5da373d76a437097fc622c29d69630.png','1','0',2,'0',2,'2023-10-15 15:25:08',2,'2023-10-15 15:25:08',0),(34,'22','22','22',3,'http://s2k69te8d.hn-bkt.clouddn.com/2023/10/15/97754bb4984c42a0a25a89d0acd89eed.png','1','0',0,'0',1,'2023-10-15 16:48:07',1,'2023-10-15 16:48:07',0);

/*Table structure for table `sg_article_tag` */

DROP TABLE IF EXISTS `sg_article_tag`;

CREATE TABLE `sg_article_tag` (
  `article_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `tag_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '标签id',
  PRIMARY KEY (`article_id`,`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8mb4 COMMENT='文章标签关联表';

/*Data for the table `sg_article_tag` */

insert  into `sg_article_tag`(`article_id`,`tag_id`) values (1,4),(1,13),(1,18),(1,20),(2,1),(2,4),(3,4),(3,5),(5,17),(6,4),(6,13),(7,1),(7,4),(7,5),(8,11),(8,12),(8,17),(9,4),(9,12),(9,13),(9,18),(9,20),(10,1),(10,4),(10,5),(10,20),(11,18),(11,20),(12,18),(12,20),(13,18),(13,20),(14,18),(14,20),(15,1),(15,4),(16,1),(16,4),(17,4),(18,1),(18,4),(19,1),(21,4),(22,10),(23,11),(24,11),(25,13),(26,10),(27,1),(29,4),(30,4),(31,4),(32,4),(33,4),(34,10);

/*Table structure for table `sg_category` */

DROP TABLE IF EXISTS `sg_category`;

CREATE TABLE `sg_category` (
  `id` bigint(200) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL COMMENT '分类名',
  `pid` bigint(200) DEFAULT '-1' COMMENT '父分类id，如果没有父分类为-1',
  `description` varchar(512) DEFAULT NULL COMMENT '描述',
  `status` char(1) DEFAULT '0' COMMENT '状态0:正常,1禁用',
  `create_by` bigint(200) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(200) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int(11) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COMMENT='分类表';

/*Data for the table `sg_category` */

insert  into `sg_category`(`id`,`name`,`pid`,`description`,`status`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'java',-1,'wsd','0',NULL,NULL,NULL,NULL,0),(2,'PHP',-1,'PHP是最好的语言233','0',NULL,NULL,NULL,NULL,0),(3,'SpringBoot',-1,'起立到起飞','0',NULL,NULL,NULL,NULL,0),(4,'springCloud',-1,'微服务','0',NULL,NULL,NULL,NULL,0),(5,'放松一下',-1,'休息区','0',NULL,NULL,NULL,NULL,0),(6,'开发工具',-1,'各种中间件、开发常用的工具','0',NULL,NULL,NULL,NULL,0),(7,'应用型笔记',-1,'记录经常使用的编程笔记','0',NULL,NULL,NULL,NULL,0),(8,'面试型笔记',-1,'记录面试、底层方面的编程笔记','0',NULL,NULL,NULL,NULL,0),(9,'111',-1,'11','0',NULL,NULL,NULL,NULL,1);

/*Table structure for table `sg_comment` */

DROP TABLE IF EXISTS `sg_comment`;

CREATE TABLE `sg_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` char(1) DEFAULT '0' COMMENT '评论类型（0代表文章评论，1代表友链评论）',
  `article_id` bigint(20) DEFAULT NULL COMMENT '文章id',
  `root_id` bigint(20) DEFAULT '-1' COMMENT '根评论id',
  `content` varchar(512) DEFAULT NULL COMMENT '评论内容',
  `to_comment_user_id` bigint(20) DEFAULT '-1' COMMENT '所回复的目标评论的userid',
  `to_comment_id` bigint(20) DEFAULT '-1' COMMENT '回复目标评论id',
  `create_by` bigint(20) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(20) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int(1) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=69 DEFAULT CHARSET=utf8mb4 COMMENT='评论表';

/*Data for the table `sg_comment` */

insert  into `sg_comment`(`id`,`type`,`article_id`,`root_id`,`content`,`to_comment_user_id`,`to_comment_id`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'0',1,-1,'asS',-1,-1,1,'2022-01-29 07:59:22',1,'2022-01-29 07:59:22',0),(2,'0',1,-1,'[哈哈]SDAS',-1,-1,1,'2022-01-29 08:01:24',1,'2022-01-29 08:01:24',0),(3,'0',1,-1,'是大多数',-1,-1,1,'2022-01-29 16:07:24',1,'2022-01-29 16:07:24',0),(4,'0',1,-1,'撒大声地',-1,-1,1,'2022-01-29 16:12:09',1,'2022-01-29 16:12:09',0),(5,'0',1,-1,'你再说什么',-1,-1,1,'2022-01-29 18:19:56',1,'2022-01-29 18:19:56',0),(6,'0',1,-1,'hffd',-1,-1,1,'2022-01-29 22:13:52',1,'2022-01-29 22:13:52',0),(9,'0',1,2,'你说什么',1,2,1,'2022-01-29 22:18:40',1,'2022-01-29 22:18:40',0),(10,'0',1,2,'哈哈哈哈[哈哈]',1,9,1,'2022-01-29 22:29:15',1,'2022-01-29 22:29:15',0),(11,'0',1,2,'we全文',1,10,3,'2022-01-29 22:29:55',1,'2022-01-29 22:29:55',0),(12,'0',1,-1,'王企鹅',-1,-1,1,'2022-01-29 22:30:20',1,'2022-01-29 22:30:20',0),(13,'0',1,-1,'什么阿是',-1,-1,1,'2022-01-29 22:30:56',1,'2022-01-29 22:30:56',0),(14,'0',1,-1,'新平顶山',-1,-1,1,'2022-01-29 22:32:51',1,'2022-01-29 22:32:51',0),(15,'0',1,-1,'2222',-1,-1,1,'2022-01-29 22:34:38',1,'2022-01-29 22:34:38',0),(16,'0',1,2,'3333',1,11,1,'2022-01-29 22:34:47',1,'2022-01-29 22:34:47',0),(17,'0',1,2,'回复weqedadsd',3,11,1,'2022-01-29 22:38:00',1,'2022-01-29 22:38:00',0),(18,'0',1,-1,'sdasd',-1,-1,1,'2022-01-29 23:18:19',1,'2022-01-29 23:18:19',0),(19,'0',1,-1,'111',-1,-1,1,'2022-01-29 23:22:23',1,'2022-01-29 23:22:23',0),(20,'0',1,1,'你说啥？',1,1,1,'2022-01-30 10:06:21',1,'2022-01-30 10:06:21',0),(21,'0',1,-1,'友链添加个呗',-1,-1,1,'2022-01-30 10:06:50',1,'2022-01-30 10:06:50',0),(22,'1',1,-1,'友链评论2',-1,-1,1,'2022-01-30 10:08:28',1,'2022-01-30 10:08:28',0),(23,'1',1,22,'回复友链评论3',1,22,1,'2022-01-30 10:08:50',1,'2022-01-30 10:08:50',0),(24,'1',1,-1,'友链评论4444',-1,-1,1,'2022-01-30 10:09:03',1,'2022-01-30 10:09:03',0),(25,'1',1,22,'收到的',1,22,1,'2022-01-30 10:13:28',1,'2022-01-30 10:13:28',0),(26,'0',1,-1,'sda',-1,-1,1,'2022-01-30 10:39:05',1,'2022-01-30 10:39:05',0),(39,'0',6,38,'can can need',7,38,7,'2023-08-12 16:08:46',7,'2023-08-12 16:08:46',0),(43,'0',11,-1,'aop!!![哈哈]',-1,-1,7,'2023-08-22 21:00:09',7,'2023-08-22 21:00:09',0),(44,'0',5,-1,'kaMi![哈哈]',-1,-1,7,'2023-08-29 15:32:27',7,'2023-08-29 15:32:27',0),(45,'0',5,44,'saMa[可爱]',7,44,1,'2023-08-29 15:33:06',1,'2023-08-29 15:33:06',0),(46,'0',11,-1,'[右哼哼]',-1,-1,7,'2023-09-15 09:19:45',7,'2023-09-15 09:19:45',0),(47,'0',1,-1,'111[哈哈]',-1,-1,1,'2023-10-13 15:56:58',1,'2023-10-13 15:56:58',0),(48,'0',1,-1,'[互粉][互粉]',-1,-1,1,'2023-10-13 15:57:17',1,'2023-10-13 15:57:17',0),(49,'0',1,2,'111',1,10,1,'2023-10-13 15:57:40',1,'2023-10-13 15:57:40',0),(50,'0',1,-1,'11111111111111',-1,-1,1,'2023-10-13 15:58:12',1,'2023-10-13 15:58:12',0),(51,'0',1,-1,'11111',-1,-1,1,'2023-10-13 15:58:22',1,'2023-10-13 15:58:22',0),(52,'0',16,-1,'你好[微笑]',-1,-1,1,'2023-10-13 16:00:50',1,'2023-10-13 16:00:50',0),(53,'0',1,-1,'发送什么事了[疑问]',-1,-1,1,'2023-10-13 16:01:18',1,'2023-10-13 16:01:18',0),(54,'0',9,-1,'你好[挖鼻]',-1,-1,1,'2023-10-13 16:40:22',1,'2023-10-13 16:40:22',0),(55,'0',10,-1,'111',-1,-1,1,'2023-10-13 16:52:39',1,'2023-10-13 16:52:39',0),(56,'0',1,-1,'[生病]',-1,-1,1,'2023-10-13 16:53:57',1,'2023-10-13 16:53:57',0),(57,'0',1,56,'你没事吧？',1,56,1,'2023-10-13 16:54:40',1,'2023-10-13 16:54:40',0),(58,'0',14,-1,'[吃惊]',-1,-1,1,'2023-10-15 11:57:17',1,'2023-10-15 11:57:17',0),(59,'0',14,58,'[衰]',1,58,1,'2023-10-15 11:57:28',1,'2023-10-15 11:57:28',0),(60,'0',14,58,'[哈哈]',1,59,1,'2023-10-15 11:57:38',1,'2023-10-15 11:57:38',0),(61,'0',1,-1,'[可爱]',-1,-1,2,'2023-10-15 20:34:15',2,'2023-10-15 20:34:15',0),(62,'0',10,-1,'444',-1,-1,2,'2023-10-15 20:37:47',2,'2023-10-15 20:37:47',0),(63,'0',10,62,'222',2,62,2,'2023-10-15 20:37:54',2,'2023-10-15 20:37:54',0),(64,'0',9,-1,'fgddd',-1,-1,2,'2023-10-15 20:39:09',2,'2023-10-15 20:39:09',0),(65,'0',9,-1,'[思考]',-1,-1,2,'2023-10-15 20:40:03',2,'2023-10-15 20:40:03',0),(66,'0',10,-1,'[太开心]',-1,-1,2,'2023-10-15 20:42:26',2,'2023-10-15 20:42:26',0),(67,'0',10,62,'[吃惊]',2,63,2,'2023-10-15 20:42:35',2,'2023-10-15 20:42:35',0),(68,'0',16,-1,'[可怜]',-1,-1,2,'2023-10-15 20:43:14',2,'2023-10-15 20:43:14',0);

/*Table structure for table `sg_link` */

DROP TABLE IF EXISTS `sg_link`;

CREATE TABLE `sg_link` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) DEFAULT NULL,
  `logo` varchar(256) DEFAULT NULL,
  `description` varchar(512) DEFAULT NULL,
  `address` varchar(128) DEFAULT NULL COMMENT '网站地址',
  `status` char(1) DEFAULT '2' COMMENT '审核状态 (0代表审核通过，1代表审核未通过，2代表未审核)',
  `create_by` bigint(20) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(20) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int(1) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COMMENT='友链';

/*Data for the table `sg_link` */

insert  into `sg_link`(`id`,`name`,`logo`,`description`,`address`,`status`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'高等数学','https://image.itbaima.net/images/173/image-20231013155115828.png','宋浩老师主讲哦','https://www.bilibili.com/video/BV1Eb411u7Fw/?spm_id_from=333.337.search-card.all.click&vd_source=d6367c1fc21883823f1fb738f86ef26','0',NULL,'2022-01-13 08:25:47',NULL,'2022-01-13 08:36:14',0),(2,'百度','https://image.itbaima.net/images/173/image-20231013208870518.png','搜索引擎','http://www.baidu.com','0',NULL,NULL,NULL,NULL,0),(3,'11','11','11','1111122','1',NULL,NULL,NULL,NULL,1);

/*Table structure for table `sg_tag` */

DROP TABLE IF EXISTS `sg_tag`;

CREATE TABLE `sg_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL COMMENT '标签名',
  `create_by` bigint(20) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(20) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int(1) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4 COMMENT='标签';

/*Data for the table `sg_tag` */

insert  into `sg_tag`(`id`,`name`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`,`remark`) values (1,'MyBatis',NULL,NULL,1,'2023-10-13 20:26:57',0,'写sql于xml中'),(2,'asdas',NULL,'2022-01-11 09:20:55',NULL,'2022-01-11 09:20:55',1,'weqw'),(3,'weqw',NULL,'2022-01-11 09:21:07',NULL,'2022-01-11 09:21:07',1,'qweqwe'),(4,'Java',NULL,'2022-01-13 15:22:43',1,'2023-10-13 20:28:28',0,'使用spring大家族建设网站'),(5,'WAD',NULL,'2022-01-13 15:22:47',NULL,'2022-01-13 15:22:47',1,'ASDAD'),(6,'c++',NULL,NULL,NULL,NULL,1,'可以操作底层的语言'),(7,'c++',7,'2023-08-10 13:21:23',7,'2023-08-11 07:03:42',0,'可以操作底层的语言'),(8,'go',7,'2023-08-11 07:09:45',7,'2023-08-11 07:09:45',1,'新兴的后端语言'),(9,'jojo',7,'2023-08-11 07:10:58',7,'2023-08-11 07:10:58',1,'动漫'),(10,'python',7,'2023-08-11 07:12:10',7,'2023-08-11 07:13:29',0,'1'),(11,'c#',7,'2023-08-11 07:12:14',7,'2023-08-11 07:13:36',0,'2'),(12,'vue',7,'2023-08-11 07:12:19',7,'2023-08-11 07:13:43',0,'3'),(13,'springBoot',7,'2023-08-11 07:12:24',7,'2023-08-11 07:13:53',0,'4'),(14,'c',7,'2023-08-11 07:12:28',7,'2023-08-11 07:13:59',0,'5'),(15,'JavaScript',7,'2023-08-11 07:12:37',7,'2023-08-11 07:14:10',0,'6'),(16,'springCloud',7,'2023-08-11 07:12:41',7,'2023-08-11 07:14:31',0,'7'),(17,'前端',7,'2023-08-15 12:58:21',7,'2023-08-15 12:58:21',0,'111'),(18,'后端',7,'2023-08-15 12:58:36',7,'2023-08-15 12:58:36',0,'222'),(19,'心得体会',7,'2023-08-21 12:42:45',7,'2023-08-21 12:42:45',0,'略'),(20,'技术资料',7,'2023-08-21 12:43:35',7,'2023-08-21 12:43:35',0,'略'),(21,'asp',1,'2023-10-13 22:17:08',1,'2023-10-13 22:17:08',0,'asp'),(22,'111',1,'2023-10-13 22:17:56',1,'2023-10-13 22:18:01',1,'111333');

/*Table structure for table `sys_menu` */

DROP TABLE IF EXISTS `sys_menu`;

CREATE TABLE `sys_menu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单ID',
  `menu_name` varchar(50) NOT NULL COMMENT '菜单名称',
  `parent_id` bigint(20) DEFAULT '0' COMMENT '父菜单ID',
  `order_num` int(4) DEFAULT '0' COMMENT '显示顺序',
  `path` varchar(200) DEFAULT '' COMMENT '路由地址',
  `component` varchar(255) DEFAULT NULL COMMENT '组件路径',
  `is_frame` int(1) DEFAULT '1' COMMENT '是否为外链（0是 1否）',
  `menu_type` char(1) DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',
  `visible` char(1) DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `status` char(1) DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `perms` varchar(100) DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) DEFAULT '#' COMMENT '菜单图标',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT '' COMMENT '备注',
  `del_flag` char(1) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2033 DEFAULT CHARSET=utf8 COMMENT='菜单权限表';

/*Data for the table `sys_menu` */

insert  into `sys_menu`(`id`,`menu_name`,`parent_id`,`order_num`,`path`,`component`,`is_frame`,`menu_type`,`visible`,`status`,`perms`,`icon`,`create_by`,`create_time`,`update_by`,`update_time`,`remark`,`del_flag`) values (1,'系统管理',0,1,'system',NULL,1,'M','0','0','','system',0,'2021-11-12 10:46:19',0,NULL,'系统管理目录','0'),(100,'用户管理',1,1,'user','system/user/index',1,'C','0','0','system:user:list','user',0,'2021-11-12 10:46:19',7,'2023-08-16 09:10:11','用户管理菜单','0'),(101,'角色管理',1,2,'role','system/role/index',1,'C','0','0','system:role:list','peoples',0,'2021-11-12 10:46:19',0,NULL,'角色管理菜单','0'),(102,'菜单管理',1,3,'menu','system/menu/index',1,'C','0','0','system:menu:list','tree-table',0,'2021-11-12 10:46:19',0,NULL,'菜单管理菜单','0'),(1001,'用户查询',100,1,'','',1,'F','0','0','system:user:query','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1002,'用户新增',100,2,'','',1,'F','0','0','system:user:add','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1003,'用户修改',100,3,'','',1,'F','0','0','system:user:edit','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1004,'用户删除',100,4,'','',1,'F','0','0','system:user:remove','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1005,'用户导出',100,5,'','',1,'F','0','0','system:user:export','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1006,'用户导入',100,6,'','',1,'F','0','0','system:user:import','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1007,'重置密码',100,7,'','',1,'F','0','0','system:user:resetPwd','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1008,'角色查询',101,1,'','',1,'F','0','0','system:role:query','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1009,'角色新增',101,2,'','',1,'F','0','0','system:role:add','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1010,'角色修改',101,3,'','',1,'F','0','0','system:role:edit','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1011,'角色删除',101,4,'','',1,'F','0','0','system:role:remove','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1012,'角色导出',101,5,'','',1,'F','0','0','system:role:export','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1013,'菜单查询',102,1,'','',1,'F','0','0','system:menu:query','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1014,'菜单新增',102,2,'','',1,'F','0','0','system:menu:add','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1015,'菜单修改',102,3,'','',1,'F','0','0','system:menu:edit','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1016,'菜单删除',102,4,'','',1,'F','0','0','system:menu:remove','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(2017,'内容管理',0,4,'content',NULL,1,'M','0','0',NULL,'table',NULL,'2022-01-08 02:44:38',1,'2022-07-31 12:34:23','','0'),(2018,'分类管理',2017,1,'category','content/category/index',1,'C','0','0','content:category:list','example',NULL,'2022-01-08 02:51:45',NULL,'2022-01-08 02:51:45','','0'),(2019,'文章管理',2017,0,'article','content/article/index',1,'C','0','0','content:article:list','build',NULL,'2022-01-08 02:53:10',NULL,'2022-01-08 02:53:10','','0'),(2021,'标签管理',2017,6,'tag','content/tag/index',1,'C','0','0','content:tag:index','button',NULL,'2022-01-08 02:55:37',NULL,'2022-01-08 02:55:50','','0'),(2022,'友链管理',2017,4,'link','content/link/index',1,'C','0','0','content:link:list','404',NULL,'2022-01-08 02:56:50',NULL,'2022-01-08 02:56:50','','0'),(2023,'写博文',0,0,'write','content/article/write/index',1,'C','0','0','content:article:writer','build',NULL,'2022-01-08 03:39:58',1,'2022-07-31 22:07:05','','0'),(2024,'友链新增',2022,0,'',NULL,1,'F','0','0','content:link:add','#',NULL,'2022-01-16 07:59:17',NULL,'2022-01-16 07:59:17','','0'),(2025,'友链修改',2022,1,'',NULL,1,'F','0','0','content:link:edit','#',NULL,'2022-01-16 07:59:44',NULL,'2022-01-16 07:59:44','','0'),(2026,'友链删除',2022,1,'',NULL,1,'F','0','0','content:link:remove','#',NULL,'2022-01-16 08:00:05',NULL,'2022-01-16 08:00:05','','0'),(2027,'友链查询',2022,2,'',NULL,1,'F','0','0','content:link:query','#',NULL,'2022-01-16 08:04:09',NULL,'2022-01-16 08:04:09','','0'),(2028,'导出分类',2018,1,'',NULL,1,'F','0','0','content:category:export','#',NULL,'2022-01-21 07:06:59',NULL,'2022-01-21 07:06:59','','0'),(2029,'标签删除',2021,0,'',NULL,1,'F','0','0','content:tag:remove','#',NULL,NULL,NULL,NULL,'','0'),(2030,'test',2023,1,'',NULL,1,'F','0','0','allPeople','#',NULL,NULL,NULL,NULL,'','1'),(2031,'test',0,3,'test',NULL,1,'M','0','0',NULL,'date',1,'2023-10-13 22:10:47',1,'2023-10-13 22:10:47','','1'),(2032,'文章是否置顶',2023,3,'isTop',NULL,1,'F','0','0','content:article:isTop','#',NULL,NULL,NULL,'2023-10-15 16:01:54','','1');

/*Table structure for table `sys_role` */

DROP TABLE IF EXISTS `sys_role`;

CREATE TABLE `sys_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(30) NOT NULL COMMENT '角色名称',
  `role_key` varchar(100) NOT NULL COMMENT '角色权限字符串',
  `role_sort` int(4) NOT NULL COMMENT '显示顺序',
  `status` char(1) NOT NULL COMMENT '角色状态（0正常 1停用）',
  `del_flag` char(1) DEFAULT '0' COMMENT '删除标志（0代表存在 1代表删除）',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COMMENT='角色信息表';

/*Data for the table `sys_role` */

insert  into `sys_role`(`id`,`role_name`,`role_key`,`role_sort`,`status`,`del_flag`,`create_by`,`create_time`,`update_by`,`update_time`,`remark`) values (1,'超级管理员','admin',1,'0','0',0,'2021-11-12 10:46:19',0,NULL,'超级管理员'),(2,'普通角色','common',2,'0','0',0,'2021-11-12 10:46:19',1,'2023-10-15 16:46:30','普通角色'),(12,'友链审核员','link',1,'0','0',NULL,'2022-01-16 06:49:30',1,'2023-10-13 21:45:10',NULL),(13,'test','test',4,'1','1',1,'2023-10-13 22:05:34',1,'2023-10-13 22:06:03','test');

/*Table structure for table `sys_role_menu` */

DROP TABLE IF EXISTS `sys_role_menu`;

CREATE TABLE `sys_role_menu` (
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  `menu_id` bigint(20) NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`,`menu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色和菜单关联表';

/*Data for the table `sys_role_menu` */

insert  into `sys_role_menu`(`role_id`,`menu_id`) values (0,0),(2,2023),(3,2),(3,3),(3,4),(3,100),(3,101),(3,103),(3,104),(3,105),(3,106),(3,107),(3,108),(3,109),(3,110),(3,111),(3,112),(3,113),(3,114),(3,115),(3,116),(3,500),(3,501),(3,1001),(3,1002),(3,1003),(3,1004),(3,1005),(3,1006),(3,1007),(3,1008),(3,1009),(3,1010),(3,1011),(3,1012),(3,1017),(3,1018),(3,1019),(3,1020),(3,1021),(3,1022),(3,1023),(3,1024),(3,1025),(3,1026),(3,1027),(3,1028),(3,1029),(3,1030),(3,1031),(3,1032),(3,1033),(3,1034),(3,1035),(3,1036),(3,1037),(3,1038),(3,1039),(3,1040),(3,1041),(3,1042),(3,1043),(3,1044),(3,1045),(3,1046),(3,1047),(3,1048),(3,1049),(3,1050),(3,1051),(3,1052),(3,1053),(3,1054),(3,1055),(3,1056),(3,1057),(3,1058),(3,1059),(3,1060),(3,2000),(11,1),(11,100),(11,101),(11,102),(11,103),(11,104),(11,105),(11,106),(11,107),(11,108),(11,500),(11,501),(11,1001),(11,1002),(11,1003),(11,1004),(11,1005),(11,1006),(11,1007),(11,1008),(11,1009),(11,1010),(11,1011),(11,1012),(11,1013),(11,1014),(11,1015),(11,1016),(11,1017),(11,1018),(11,1019),(11,1020),(11,1021),(11,1022),(11,1023),(11,1024),(11,1025),(11,1026),(11,1027),(11,1028),(11,1029),(11,1030),(11,1031),(11,1032),(11,1033),(11,1034),(11,1035),(11,1036),(11,1037),(11,1038),(11,1039),(11,1040),(11,1041),(11,1042),(11,1043),(11,1044),(11,1045),(11,2000),(11,2003),(11,2004),(11,2005),(11,2006),(11,2007),(11,2008),(11,2009),(11,2010),(11,2011),(11,2012),(11,2013),(11,2014),(12,2017),(12,2022),(12,2023),(12,2024),(12,2025),(12,2026),(12,2027),(12,2032),(13,2017),(13,2018),(13,2019),(13,2021),(13,2023),(13,2028),(13,2029),(14,1),(14,100),(15,2031),(15,2032),(16,2023),(16,2030);

/*Table structure for table `sys_user` */

DROP TABLE IF EXISTS `sys_user`;

CREATE TABLE `sys_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `type` char(1) DEFAULT '0' COMMENT '用户类型：0代表普通用户，1代表管理员',
  `status` char(1) DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` varchar(64) DEFAULT NULL COMMENT '邮箱',
  `phonenumber` varchar(32) DEFAULT NULL COMMENT '手机号',
  `sex` char(1) DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` varchar(128) DEFAULT NULL COMMENT '头像',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `del_flag` int(11) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14787164048670 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';

/*Data for the table `sys_user` */

insert  into `sys_user`(`id`,`user_name`,`nick_name`,`password`,`type`,`status`,`email`,`phonenumber`,`sex`,`avatar`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'admin','admin','$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy','1','0','110@qq.com','18888888888','0','https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F3bf9c263bc0f2ac5c3a7feb9e218d07475573ec8.gi',NULL,'2022-01-05 09:01:56',1,'2023-10-15 12:10:48',0),(2,'test','kana111','$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy','0','0','120@163.com','14532241189','1','http://ryhyqcp22.hn-bkt.clouddn.com/2023/08/12/39c236b2f807489d90c89278d69fcba3.png',NULL,NULL,1,'2023-10-15 21:01:24',0),(6,'link','sangeng','$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy','0','0','2312321','17777777777','0',NULL,NULL,'2022-01-16 06:54:26',NULL,'2022-01-16 07:06:34',0),(7,'kana','kana','$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy','1','0','2587441565@qq.com','13435541185','0','http://ryhyqcp22.hn-bkt.clouddn.com/2023/08/12/39c236b2f807489d90c89278d69fcba3.png',NULL,'2023-08-19 16:28:15',1,'2023-10-15 21:01:04',0),(14787164048668,'L1','L','$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy','0','0','123@123.com','13432941186','0',NULL,7,'2023-08-19 09:39:50',7,'2023-08-19 09:39:50',1),(14787164048669,'222','111','$2a$10$A2TYZHDga0ciUSCEVmx37O2aavDx5xjzYMDwq5wCm7oshLhrtzkTC','0','1','123et@163.com','13572241188','0',NULL,1,'2023-10-13 21:23:57',1,'2023-10-15 21:01:16',0);

/*Table structure for table `sys_user_role` */

DROP TABLE IF EXISTS `sys_user_role`;

CREATE TABLE `sys_user_role` (
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  PRIMARY KEY (`user_id`,`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户和角色关联表';

/*Data for the table `sys_user_role` */

insert  into `sys_user_role`(`user_id`,`role_id`) values (1,1),(2,2),(5,2),(6,12),(7,1),(14787164048668,2),(14787164048668,15),(14787164048669,2);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
